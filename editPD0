#!/usr/bin/perl
#======================================================================
#                    E D I T P D 0 
#                    doc: Mon Nov 25 20:24:31 2013
#                    dlm: Fri Feb 26 17:24:55 2016
#                    (c) 2013 A.M. Thurnherr
#                    uE-Info: 26 98 NIL 0 0 72 2 2 4 NIL ofnI
#======================================================================

# edit RDI PD0 file, e.g. to replace pitch/roll/heading with external values

# NOTES:
#
#	- editing instructions can be provided either in an editing file (primarily
#	  for ensemble-specific editing), or with the -x option on the command line
#	  (only or editing applied to all ensembles)
#
#	- Data-Editing Library:
#		p(<pitch>)				set pitch value (RDI not gimbal pitch) of current ensemble
#		r(<roll>)				set roll alue value of current ensemble
#		h(<heading>)			set heading alue value of current ensemble
#
#		swap_beams(<b1>,<b2>)	swap data from beams b1 and b2
#								input in beam coords required
#								beam rotation is equivalent to 3 consecutive beam swaps
#								basic BT data are swapped as well (not RL and not SIGNAL_STRENGTH)
#
#		earth2beam()			transform beam to earth coordinates
#								does not handle bin-remapping
#								input in beam coords required
#
#		ensure_UL()				overwrite transducer-orientation flag in data file
#		ensure_DL()
#
#	- -x notes:
#		- multiple perl expressions can be combined with ,
#
#	- Edit File Syntax:
#		- # comments ignored
#		- empty lines ignored
#       - [space] <ensemble-number|*> <space> <perl-expr>
#		- Examples:
#       	162     p(3), r(4), h(3.14)

# HISTORY:
#   Nov 25, 2013: - created
#   Dec 18, 2015: - added switch_beams()
#                 - added -x
#	Jan  9, 2016: - renamed switch_beams() to swap_beams()
#				  - wrote documentation
#				  - change output data-source ID from 0x7F to 0xE0
#				  - updated getopts to current perl version
#				  - adapted to [ADCP_tools_lib.pl]
#	Feb 15, 2016: - added ensure_UL() ensure_DL()
#	Feb 23, 2016: - added -k
#	Feb 26, 2016: - added basic BT data to swap_beams()

use Getopt::Std;

($ADCP_TOOLS) = ($0 =~ m{(.*/)[^/]+});
$ADCP_tools_minVersion = 1.4; 
require "$ADCP_TOOLS/ADCP_tools_lib.pl";

$USAGE = "$0 @ARGV";
die("Usage: $0 " .
    '-e) <edit-file> | -x) <expr> ' .
    '-k)eep original data-source id' .
    "<input file> <output file>\n")
        unless (&getopts('ke:x:') && @ARGV == 2);

die("$0: -e <edit-file> or -x <expr> required\n")
    unless (defined($opt_x) || -r $opt_e);

print(STDERR "Reading $ARGV[0]...");                # read data
readData($ARGV[0],\%dta);
print(STDERR "done\n");

#----------------------------------------------------------------------

print(STDERR "Editing Data...");                

#--------------------------------------------------
# Data Editing Library
#--------------------------------------------------

#
# override pitch/roll/heading
#
sub p($) { $dta{ENSEMBLE}[$e]->{PITCH} = $_[0]; return 1; }
sub r($) { $dta{ENSEMBLE}[$e]->{ROLL} = $_[0]; return 1; }
sub h($) { $dta{ENSEMBLE}[$e]->{HEADING} = $_[0]; return 1;}

#
# override transducer orientation
#
sub ensure_DL()
{
	$dta{ENSEMBLE}[$e]->{XDUCER_FACING_DOWN} = 1;
	$dta{ENSEMBLE}[$e]->{XDUCER_FACING_UP} = undef;
	return 1;
}
sub ensure_UL()
{
	$dta{ENSEMBLE}[$e]->{XDUCER_FACING_DOWN} = undef;
	$dta{ENSEMBLE}[$e]->{XDUCER_FACING_UP} = 1;
	return 1;
}

#
# swap data from two mis-connected beams
#
sub swap_beams($$)
{
	my($b1,$b2) = @_;
	my($tmp);

#	print(STDERR "\n entering swap_beams($b1,$b2) for ens = $e...");

	die("$ARGV[0]: beam-coordinate data required\n")
		unless ($dta{BEAM_COORDINATES});

	if ($dta{BT_PRESENT}) {
		$tmp = $dta{ENSEMBLE}[$e]->{BT_RANGE}[$b1-1];
		$dta{ENSEMBLE}[$e]->{BT_RANGE}[$b1-1] = $dta{ENSEMBLE}[$e]->{BT_RANGE}[$b2-1];
		$dta{ENSEMBLE}[$e]->{BT_RANGE}[$b2-1] = $tmp;
		                
		$tmp = $dta{ENSEMBLE}[$e]->{BT_VELOCITY}[$b1-1];
		$dta{ENSEMBLE}[$e]->{BT_VELOCITY}[$b1-1] = $dta{ENSEMBLE}[$e]->{BT_VELOCITY}[$b2-1];
		$dta{ENSEMBLE}[$e]->{BT_VELOCITY}[$b2-1] = $tmp;
		                
		$tmp = $dta{ENSEMBLE}[$e]->{BT_CORRELATION}[$b1-1];
		$dta{ENSEMBLE}[$e]->{BT_CORRELATION}[$b1-1] = $dta{ENSEMBLE}[$e]->{BT_CORRELATION}[$b2-1];
		$dta{ENSEMBLE}[$e]->{BT_CORRELATION}[$b2-1] = $tmp;
		                
		$tmp = $dta{ENSEMBLE}[$e]->{BT_EVAL_AMPLITUDE}[$b1-1];
		$dta{ENSEMBLE}[$e]->{BT_EVAL_AMPLITUDE}[$b1-1] = $dta{ENSEMBLE}[$e]->{BT_EVAL_AMPLITUDE}[$b2-1];
		$dta{ENSEMBLE}[$e]->{BT_EVAL_AMPLITUDE}[$b2-1] = $tmp;
		                
		$tmp = $dta{ENSEMBLE}[$e]->{BT_PERCENT_GOOD}[$b1-1];
		$dta{ENSEMBLE}[$e]->{BT_PERCENT_GOOD}[$b1-1] = $dta{ENSEMBLE}[$e]->{BT_PERCENT_GOOD}[$b2-1];
		$dta{ENSEMBLE}[$e]->{BT_PERCENT_GOOD}[$b2-1] = $tmp;
    }		                

	for (my($bin)=0; $bin<$dta{N_BINS}; $bin++) {
		$tmp = $dta{ENSEMBLE}[$e]->{VELOCITY}[$bin][$b1-1];
		$dta{ENSEMBLE}[$e]->{VELOCITY}[$bin][$b1-1] = $dta{ENSEMBLE}[$e]->{VELOCITY}[$bin][$b2-1];
		$dta{ENSEMBLE}[$e]->{VELOCITY}[$bin][$b2-1] = $tmp;

		$tmp = $dta{ENSEMBLE}[$e]->{CORRELATION}[$bin][$b1-1];
		$dta{ENSEMBLE}[$e]->{CORRELATION}[$bin][$b1-1] = $dta{ENSEMBLE}[$e]->{CORRELATION}[$bin][$b2-1];
		$dta{ENSEMBLE}[$e]->{CORRELATION}[$bin][$b2-1] = $tmp;

		$tmp = $dta{ENSEMBLE}[$e]->{ECHO_AMPLITUDE}[$bin][$b1-1];
		$dta{ENSEMBLE}[$e]->{ECHO_AMPLITUDE}[$bin][$b1-1] = $dta{ENSEMBLE}[$e]->{ECHO_AMPLITUDE}[$bin][$b2-1];
		$dta{ENSEMBLE}[$e]->{ECHO_AMPLITUDE}[$bin][$b2-1] = $tmp;

		$tmp = $dta{ENSEMBLE}[$e]->{PERCENT_GOOD}[$bin][$b1-1];
		$dta{ENSEMBLE}[$e]->{PERCENT_GOOD}[$bin][$b1-1] = $dta{ENSEMBLE}[$e]->{PERCENT_GOOD}[$bin][$b2-1];
		$dta{ENSEMBLE}[$e]->{PERCENT_GOOD}[$bin][$b2-1] = $tmp;
	}
	return 1;
}


#
# transform earth to beam coordinates
#
{ my($checked);

	sub earth2beam()
	{
		unless ($checked) {
			die("$ARGV[0]: earth-coordinate data required\n")
				unless ($dta{EARTH_COORDINATES});
			$dta{BEAM_COORDINATES} = 1; undef($dta{EARTH_COORDINATES});
			$checked = 1;
		}
	    
		for (my($bin)=0; $bin<$dta{N_BINS}; $bin++) {
			@{$dta{ENSEMBLE}[$e]->{VELOCITY}[$bin]} =
				velEarthToBeam(\%dta,$e,@{$dta{ENSEMBLE}[$e]->{VELOCITY}[$bin]});
		}
	
		return 1;
	}

}

#--------------------------------------------------
# Main Routine
#--------------------------------------------------

if (defined($opt_x)) {															# edit instructions on the command line
	push(@EE,'*');
	my($id) = ($opt_x =~ m/^([A-Z]+)\s/);										# e.g. PITCH, ROLL, HEADING
	$opt_x = sprintf('$dta{ENSEMBLE}[$e]->{%s}',$id)
		if defined($id);
	push(@EX,$opt_x);
}		

if (defined($opt_e)) {															# edit instructions in edit file
	open(EF,$opt_e) || die("$opt_e: $!\n");
	while (<EF>) {
		s/\#.*//;
		next if m/^\s+$/;
		my($ens,$expr) = m/^\s*(\*|\d+)\s+(.*)$/;
	
		my($id) = ($expr =~ m/^([A-Z]+)\s/);										# e.g. PITCH, ROLL, HEADING
		$expr = sprintf('$dta{ENSEMBLE}[$e]->{%s}',$id)
			if defined($id);
		    
		push(@EE,$ens);
		push(@EX,$expr);
	}
	close(EF);
}

for (local($e)=my($eei)=0; $e<@{$dta{ENSEMBLE}}; $e++) {						# local() needed for p(), r(), h()
	$dta{ENSEMBLE}[$e]->{DATA_SOURCE_ID} = 0xE0									# mark all ensembles except first
		unless ($opt_k || $e==0);
	if ($EE[$eei] eq '*' || $EE[$eei] == $dta{ENSEMBLE}[$e]->{NUMBER}) {		# match => edit
		eval($EX[$eei]) || die("$@ while executing <$EX[$eei]>\n");
	} elsif ($EE[$eei] > $dta{ENSEMBLE}[$e]->{NUMBER}) {						# next edit later in file => skip
		next;
	} else {																	# need next edit
		$eei++;
		last if ($eei >= @EE);
		redo;
	}
}

print(STDERR "done\n");

#----------------------------------------------------------------------

print(STDERR "Writing $ARGV[1]...");				# write data
writeData($ARGV[1],\%dta);
print(STDERR "done\n");

exit(0);
